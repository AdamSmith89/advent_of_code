use advent_of_code::year2023::day12::*;

const PUZZLE_INPUT: &str = include_str!("../../input/year2023/day12.txt");
const EXAMPLE_INPUT: &str = "\
???.### 1,1,3
.??..??...?##. 1,1,3
?#?#?#?#?#?#?#? 1,3,1,6
????.#...#... 4,1,1
????.######..#####. 1,6,5
?###???????? 3,2,1";

#[test]
fn parse_example() {
    let parsed = parse(EXAMPLE_INPUT).expect("Error parsing input");

    assert_eq!(
        parsed,
        Input {
            part1: vec![
                Row {
                    springs: vec!['?', '?', '?', '.', '#', '#', '#'],
                    groups: vec![1, 1, 3],
                },
                Row {
                    springs: vec![
                        '.', '?', '?', '.', '.', '?', '?', '.', '.', '.', '?', '#', '#', '.'
                    ],
                    groups: vec![1, 1, 3],
                },
                Row {
                    springs: vec![
                        '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?'
                    ],
                    groups: vec![1, 3, 1, 6],
                },
                Row {
                    springs: vec!['?', '?', '?', '?', '.', '#', '.', '.', '.', '#', '.', '.', '.'],
                    groups: vec![4, 1, 1],
                },
                Row {
                    springs: vec![
                        '?', '?', '?', '?', '.', '#', '#', '#', '#', '#', '#', '.', '.', '#', '#',
                        '#', '#', '#', '.'
                    ],
                    groups: vec![1, 6, 5],
                },
                Row {
                    springs: vec!['?', '#', '#', '#', '?', '?', '?', '?', '?', '?', '?', '?'],
                    groups: vec![3, 2, 1],
                },
            ],
            part2: vec![
                Row {
                    springs: vec![
                        '?', '?', '?', '.', '#', '#', '#', '?', '?', '?', '?', '.', '#', '#', '#',
                        '?', '?', '?', '?', '.', '#', '#', '#', '?', '?', '?', '?', '.', '#', '#',
                        '#', '?', '?', '?', '?', '.', '#', '#', '#'
                    ],
                    groups: vec![1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 3],
                },
                Row {
                    springs: vec![
                        '.', '?', '?', '.', '.', '?', '?', '.', '.', '.', '?', '#', '#', '.', '?',
                        '.', '?', '?', '.', '.', '?', '?', '.', '.', '.', '?', '#', '#', '.', '?',
                        '.', '?', '?', '.', '.', '?', '?', '.', '.', '.', '?', '#', '#', '.', '?',
                        '.', '?', '?', '.', '.', '?', '?', '.', '.', '.', '?', '#', '#', '.', '?',
                        '.', '?', '?', '.', '.', '?', '?', '.', '.', '.', '?', '#', '#', '.'
                    ],
                    groups: vec![1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 3],
                },
                Row {
                    springs: vec![
                        '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?',
                        '?', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#',
                        '?', '?', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?',
                        '#', '?', '?', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#',
                        '?', '#', '?', '?', '?', '#', '?', '#', '?', '#', '?', '#', '?', '#', '?',
                        '#', '?', '#', '?'
                    ],
                    groups: vec![1, 3, 1, 6, 1, 3, 1, 6, 1, 3, 1, 6, 1, 3, 1, 6, 1, 3, 1, 6],
                },
                Row {
                    springs: vec![
                        '?', '?', '?', '?', '.', '#', '.', '.', '.', '#', '.', '.', '.', '?', '?',
                        '?', '?', '?', '.', '#', '.', '.', '.', '#', '.', '.', '.', '?', '?', '?',
                        '?', '?', '.', '#', '.', '.', '.', '#', '.', '.', '.', '?', '?', '?', '?',
                        '?', '.', '#', '.', '.', '.', '#', '.', '.', '.', '?', '?', '?', '?', '?',
                        '.', '#', '.', '.', '.', '#', '.', '.', '.'
                    ],
                    groups: vec![4, 1, 1, 4, 1, 1, 4, 1, 1, 4, 1, 1, 4, 1, 1],
                },
                Row {
                    springs: vec![
                        '?', '?', '?', '?', '.', '#', '#', '#', '#', '#', '#', '.', '.', '#', '#',
                        '#', '#', '#', '.', '?', '?', '?', '?', '?', '.', '#', '#', '#', '#', '#',
                        '#', '.', '.', '#', '#', '#', '#', '#', '.', '?', '?', '?', '?', '?', '.',
                        '#', '#', '#', '#', '#', '#', '.', '.', '#', '#', '#', '#', '#', '.', '?',
                        '?', '?', '?', '?', '.', '#', '#', '#', '#', '#', '#', '.', '.', '#', '#',
                        '#', '#', '#', '.', '?', '?', '?', '?', '?', '.', '#', '#', '#', '#', '#',
                        '#', '.', '.', '#', '#', '#', '#', '#', '.'
                    ],
                    groups: vec![1, 6, 5, 1, 6, 5, 1, 6, 5, 1, 6, 5, 1, 6, 5],
                },
                Row {
                    springs: vec![
                        '?', '#', '#', '#', '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', '#',
                        '#', '#', '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', '#', '#', '#',
                        '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', '#', '#', '#', '?', '?',
                        '?', '?', '?', '?', '?', '?', '?', '?', '#', '#', '#', '?', '?', '?', '?',
                        '?', '?', '?', '?'
                    ],
                    groups: vec![3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1],
                },
            ],
        }
    );
}

#[test]
fn part1_example() {
    let input = parse(EXAMPLE_INPUT).expect("Error parsing input");
    let answer = part1(&input).expect("Error solving part 1");

    assert_eq!(answer, 21);
}

#[test]
fn part1_real() {
    let parsed = parse(PUZZLE_INPUT).expect("Error parsing input");
    let answer = part1(&parsed).expect("Error solving part 1");

    assert_eq!(answer, 7857);
}

#[test]
fn part2_example() {
    let input = parse(EXAMPLE_INPUT).expect("Error parsing example input");
    let answer = part2(&input).expect("Error solving part 2");

    assert_eq!(answer, 525152);
}

#[test]
fn part2_real() {
    let parsed = parse(PUZZLE_INPUT).expect("Error parsing input");
    let answer = part2(&parsed).expect("Error solving part 2");

    assert_eq!(answer, 28606137449920);
}
